name: Build PDFs from Markdown (recursive)

on:
  workflow_dispatch:
    inputs:
      include_root:
        description: "Generate root.pdf (includes ALL markdown recursively)"
        required: false
        default: "true"
      output_dir:
        description: "Output folder at repo root"
        required: false
        default: "generated-pdf"
      commit_back:
        description: "Commit generated PDFs back to the repository"
        required: false
        default: "false"
      pdf_engine:
        description: "PDF engine (xelatex recommended)"
        required: false
        default: "xelatex"

  push:
    branches: ["main"]
    paths-ignore:
      - "generated-pdf/**"

permissions:
  contents: write

jobs:
  build:
    runs-on: ubuntu-24.04

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Build PDFs (Pandoc + LaTeX container)
        env:
          INCLUDE_ROOT: ${{ github.event.inputs.include_root || 'true' }}
          OUTPUT_DIR: ${{ github.event.inputs.output_dir || 'generated-pdf' }}
          COMMIT_BACK: ${{ github.event.inputs.commit_back || 'false' }}
          PDF_ENGINE: ${{ github.event.inputs.pdf_engine || 'xelatex' }}
        run: |
          set -eu

          echo "INCLUDE_ROOT=$INCLUDE_ROOT"
          echo "OUTPUT_DIR=$OUTPUT_DIR"
          echo "PDF_ENGINE=$PDF_ENGINE"
          echo "COMMIT_BACK=$COMMIT_BACK"

          docker run --rm \
            -v "${GITHUB_WORKSPACE}:/data" \
            -w /data \
            -e INCLUDE_ROOT="${INCLUDE_ROOT}" \
            -e OUTPUT_DIR="${OUTPUT_DIR}" \
            -e PDF_ENGINE="${PDF_ENGINE}" \
            pandoc/latex:3.8 \
            /bin/sh -lc '
              set -eu

              OUTPUT_DIR="${OUTPUT_DIR:-generated-pdf}"
              INCLUDE_ROOT="${INCLUDE_ROOT:-true}"
              PDF_ENGINE="${PDF_ENGINE:-xelatex}"

              mkdir -p "$OUTPUT_DIR"

              # Exclude common dirs + output dir itself (generalized)
              # Add/remove patterns as needed.
              EX1="*/.git/*"
              EX2="*/.github/*"
              EX3="*/node_modules/*"
              EX4="*/dist/*"
              EX5="*/build/*"
              EX6="*/target/*"
              EX7="*/vendor/*"
              EX8="*/${OUTPUT_DIR}/*"

              collect_md() {
                base="$1"
                # Collect markdown recursively, excluding common dirs
                find "$base" -type f -name "*.md" \
                  ! -path "$EX1" ! -path "$EX2" ! -path "$EX3" ! -path "$EX4" \
                  ! -path "$EX5" ! -path "$EX6" ! -path "$EX7" ! -path "$EX8" \
                  | LC_ALL=C sort
              }

              build_resource_path_from_listfile() {
                listfile="$1"
                # resource-path includes repo root + each markdown file directory (unique) joined with :
                {
                  echo "."
                  while IFS= read -r f; do
                    d=$(dirname "$f")
                    echo "$d"
                  done < "$listfile"
                } | awk "!seen[\$0]++ { out = (out==\"\" ? \$0 : out\":\"\$0) } END { print out }"
              }

              build_combined_md() {
                base="$1"
                listfile="$2"
                tmpmd="$3"

                # Title
                if [ "$base" = "." ]; then
                  echo "# root" > "$tmpmd"
                else
                  echo "# $(basename "$base")" > "$tmpmd"
                fi
                echo "" >> "$tmpmd"

                # Add each file with an H1 heading => bookmarks / outline entries
                while IFS= read -r f; do
                  # Label is path relative to base (or repo root)
                  if [ "$base" = "." ]; then
                    label="${f#./}"
                  else
                    label="${f#"$base"/}"
                  fi
                  echo "# $label" >> "$tmpmd"
                  echo "" >> "$tmpmd"
                  cat "$f" >> "$tmpmd"
                  echo "" >> "$tmpmd"
                  echo "" >> "$tmpmd"
                done < "$listfile"
              }

              build_pdf_for_scope() {
                base="$1"           # "." or "folder"
                outpdf="$2"          # output path
                title="$3"           # metadata title

                listfile="$(mktemp)"
                tmpmd="$(mktemp)"

                collect_md "$base" > "$listfile"

                # If no files, skip
                if [ ! -s "$listfile" ]; then
                  echo "No markdown files under $base"
                  rm -f "$listfile" "$tmpmd"
                  return 0
                fi

                respath="$(build_resource_path_from_listfile "$listfile")"
                build_combined_md "$base" "$listfile" "$tmpmd"

                echo "==> Building $outpdf"
                pandoc --from gfm \
                  --standalone \
                  --toc \
                  --pdf-engine="$PDF_ENGINE" \
                  --metadata title="$title" \
                  --resource-path="$respath" \
                  -o "$outpdf" \
                  "$tmpmd"

                rm -f "$listfile" "$tmpmd"
              }

              # 1) One PDF per first-level folder (recursively includes nested md)
              find . -mindepth 1 -maxdepth 1 -type d | LC_ALL=C sort | while IFS= read -r d; do
                d="${d#./}"

                # skip excluded top-level folders
                case "$d" in
                  .git|.github|node_modules|dist|build|target|vendor|"$OUTPUT_DIR")
                    continue
                    ;;
                esac

                outpdf="${OUTPUT_DIR}/${d}.pdf"
                build_pdf_for_scope "$d" "$outpdf" "$d"
              done

              # 2) Optional: root.pdf including all md recursively
              case "$INCLUDE_ROOT" in
                true|True|1|yes|YES|y|Y)
                  build_pdf_for_scope "." "${OUTPUT_DIR}/root.pdf" "root"
                  ;;
                *)
                  echo "Skipping root.pdf (INCLUDE_ROOT=$INCLUDE_ROOT)"
                  ;;
              esac

              echo ""
              echo "Generated PDFs:"
              ls -lah "$OUTPUT_DIR" || true
            '

      - name: Upload PDFs as artifact
        uses: actions/upload-artifact@v4
        with:
          name: generated-pdfs
          path: ${{ github.event.inputs.output_dir || 'generated-pdf' }}/

      - name: Commit PDFs back to repo (optional)
        if: ${{ (github.event.inputs.commit_back || 'false') == 'true' }}
        run: |
          set -eu
          OUT="${{ github.event.inputs.output_dir || 'generated-pdf' }}"

          git config user.name "github-actions[bot]"
          git config user.email "github-actions[bot]@users.noreply.github.com"

          if [ -n "$(git status --porcelain "$OUT")" ]; then
            git add "$OUT"
            git commit -m "chore: update generated PDFs"
            git push
          else
            echo "No changes to commit."
          fi
